<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Duckcraft — Mod Runtime </title>
  <style>
    :root{--bg:#04101a;--accent:#ffd166;--muted:#9aa6b2;--danger:#ff6b6b}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#04101a,#052038);color:#e6eef6}
    .wrap{padding:12px}
    header{display:flex;gap:12px;align-items:center}
    header h2{margin:0;color:var(--accent);font-size:16px}
    .panel{margin-top:12px;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    pre{white-space:pre-wrap;margin:0;color:#dfeef6;font-size:13px}
    .log{margin-top:8px;max-height:180px;overflow:auto;background:rgba(0,0,0,0.15);padding:8px;border-radius:6px}
    .status{margin-top:8px;font-size:13px;color:var(--muted)}
    .error{color:var(--danger)}
    .controls{margin-top:10px;display:flex;gap:8px}
    button{background:var(--accent);border:none;color:#072024;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    canvas{display:block;margin-top:12px;background:#00121a;border-radius:6px;width:100%;height:240px}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap" role="main" aria-live="polite">
    <header>
      <h2 id="title">Duckcraft Mod Runtime</h2>
    </header>

    <div class="panel">
      <div><strong>Manifest</strong></div>
      <pre id="manifest">No manifest loaded.</pre>

      <div class="status" id="status">Waiting for host init...</div>

      <div class="controls">
        <button id="ping">Ping Host</button>
        <button id="unload">Unload Mod</button>
      </div>

      <div class="log" id="log"></div>

      <canvas id="modCanvas" width="800" height="400" aria-label="Mod rendering canvas"></canvas>

      <div class="small" style="margin-top:8px;">
        Notes: The parent must transfer a MessagePort when sending the init message. See debugging tips below.
      </div>
    </div>
  </div>

  <script>
  (function () {
    'use strict';

    const manifestEl = document.getElementById('manifest');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const pingBtn = document.getElementById('ping');
    const unloadBtn = document.getElementById('unload');
    const canvas = document.getElementById('modCanvas');

    let port = null;               // MessagePort to host
    let manifest = null;
    let baseUrl = null;
    let modModule = null;          // imported module
    let pending = new Map();
    let reqId = 1;

    function now() { return new Date().toISOString().slice(11,23); }
    function log(msg, level='info') {
      const d = document.createElement('div');
      d.textContent = `${now()} — ${msg}`;
      if (level === 'error') d.style.color = 'var(--danger)';
      logEl.appendChild(d);
      logEl.scrollTop = logEl.scrollHeight;
      console[level === 'error' ? 'error' : 'log']('[mod-runtime]', msg);
    }
    function setStatus(s, isErr=false) {
      statusEl.textContent = s;
      statusEl.className = isErr ? 'error' : '';
    }

    // handle messages that arrive on the transferred MessagePort
    function handlePortMessage(ev) {
      const data = ev.data;
      if (!data || typeof data !== 'object') return;

      if (data.type === 'response' && data.id) {
        const rec = pending.get(data.id);
        if (rec) {
          clearTimeout(rec.t);
          pending.delete(data.id);
          if (data.ok) rec.resolve(data.result);
          else rec.reject(new Error(data.error || 'Host error'));
        }
        return;
      }

      if (data.type === 'event') {
        // deliver to mod's onHostMessage/onMessage if present
        try {
          if (modModule && typeof modModule.onHostMessage === 'function') {
            modModule.onHostMessage(data.event || {});
          } else {
            log('Host event: ' + JSON.stringify(data.event || {}));
          }
        } catch (e) {
          log('Error delivering host event to mod: ' + e.message, 'error');
        }
        return;
      }

      if (data.type === 'control' && data.cmd === 'unload') {
        unloadMod();
        return;
      }
    }

    function installPort(p) {
      if (port) try { port.close(); } catch(e) {}
      port = p;
      port.onmessage = handlePortMessage;
      // Some browsers need port.start()
      try { port.start && port.start(); } catch (e) {}
    }

    // send a request to host via port, returns Promise
    function requestHost(action, payload = {}) {
      if (!port) return Promise.reject(new Error('No port to host'));
      const id = 'r' + (reqId++);
      const msg = { type: 'request', id, action, payload };
      return new Promise((resolve, reject) => {
        const t = setTimeout(() => { pending.delete(id); reject(new Error('Host timed out')); }, 30000);
        pending.set(id, { resolve, reject, t });
        try { port.postMessage(msg); } catch (err) { clearTimeout(t); pending.delete(id); reject(err); }
      });
    }

    // Try dynamic import, fall back to fetch+blob import, and finally to using entryContent if provided by host
    async function importModuleUrl(url, fallbackCode) {
      // If url is a blob URL we can import directly
      try {
        log('Attempting dynamic import from ' + url);
        return await import(url);
      } catch (err) {
        log('Direct import failed: ' + err.message);
        // try fetch + blob
        try {
          const resp = await fetch(url, { credentials: 'omit', mode: 'cors' });
          if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
          const code = await resp.text();
          const blob = new Blob([code], { type: 'application/javascript' });
          const blobUrl = URL.createObjectURL(blob);
          try {
            log('Importing from blob URL fallback');
            return await import(blobUrl);
          } finally {
            // revoke later (keep a bit for execution)
            setTimeout(() => URL.revokeObjectURL(blobUrl), 30000);
          }
        } catch (err2) {
          log('Fetch+blob import failed: ' + err2.message);
          // fallback to entry content provided by host (string)
          if (fallbackCode) {
            log('Using entryContent provided by host');
            const blob = new Blob([fallbackCode], { type: 'application/javascript' });
            const blobUrl = URL.createObjectURL(blob);
            try {
              return await import(blobUrl);
            } finally {
              setTimeout(() => URL.revokeObjectURL(blobUrl), 30000);
            }
          }
          throw new Error('All import methods failed: ' + err.message + ' / ' + (err2 && err2.message));
        }
      }
    }

    async function loadAndStart(manifestObj, manifestBaseUrl, entryContent) {
      manifest = manifestObj || {};
      baseUrl = manifestBaseUrl || baseUrl || location.href.replace(/[^\/]*$/, '');
      manifestEl.textContent = JSON.stringify(manifest, null, 2);
      setStatus('Loading entry...');

      if (!manifest.entry) {
        setStatus('manifest.entry missing', true);
        throw new Error('manifest.entry missing');
      }

      const entryUrl = new URL(manifest.entry, baseUrl).href;
      try {
        modModule = await importModuleUrl(entryUrl, entryContent);
      } catch (err) {
        log('Import error: ' + err.message, 'error');
        setStatus('Failed to import module: ' + err.message, true);
        // notify host about failure if possible
        try { port && port.postMessage({ type: 'status', status: 'import_failed', error: err.message }); } catch (e) {}
        throw err;
      }

      if (!modModule || typeof modModule.init !== 'function') {
        setStatus('Module missing init(hostApi)', true);
        throw new Error('Module must export init(hostApi)');
      }

      // prepare hostApi minimal surface
      const hostApi = {
        log: (...args) => {
          try { requestHost('log', { args }).catch(()=>{}); } catch(e){}
          log('[mod] ' + args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' '));
        },
        request: (action, payload) => requestHost(action, payload),
        getManifest: () => manifest,
        getBaseUrl: () => baseUrl,
        getCanvas: () => canvas
      };

      try {
        const maybePromise = modModule.init(hostApi);
        if (maybePromise && typeof maybePromise.then === 'function') await maybePromise;
        setStatus('Mod initialized');
        log('Mod init completed');
        try { port && port.postMessage({ type: 'status', status: 'mod_initialized' }); } catch (e) {}
      } catch (err) {
        setStatus('Mod init threw: ' + err.message, true);
        log('Mod init error: ' + (err.stack || err.message), 'error');
        throw err;
      }
    }

    function unloadMod() {
      try {
        if (modModule && typeof modModule.destroy === 'function') {
          modModule.destroy();
        }
      } catch (e) {
        log('Error during mod destroy: ' + e.message, 'error');
      }
      modModule = null;
      manifest = null;
      manifestEl.textContent = 'No manifest loaded.';
      setStatus('Unloaded');
      log('Mod unloaded');
    }

    // parent handshake: listen for init message with transferred MessagePort.
    window.addEventListener('message', async (ev) => {
      try {
        const data = ev.data;
        if (!data || data.type !== 'init') return;
        // prefer transferred port (ev.ports[0])
        const receivedPort = ev.ports && ev.ports[0];
        if (!receivedPort && data.port === 'attached') {
          // some hosts may try to send port differently; log and continue
          log('Init received but no MessagePort was transferred');
        } else if (receivedPort) {
          installPort(receivedPort);
          log('MessagePort received from host');
        }

        // manifest and baseUrl (server should provide baseUrl where mod files are hosted)
        const man = data.manifest || null;
        const bUrl = data.baseUrl || data.modBaseUrl || null;
        // optional: host can send the file contents of the entry as a string to avoid CORS issues
        const entryContent = data.entryContent || null;

        try {
          await loadAndStart(man, bUrl, entryContent);
        } catch (err) {
          // already handled inside loadAndStart
        }
      } catch (err) {
        log('Error handling init message: ' + err.message, 'error');
        setStatus('Init handling error: ' + err.message, true);
      }
    });

    // UI buttons
    pingBtn.addEventListener('click', async () => {
      setStatus('Pinging host...');
      try {
        const res = await requestHost('ping', { ts: Date.now() });
        setStatus('Host replied: ' + JSON.stringify(res));
      } catch (err) {
        setStatus('Ping failed: ' + err.message, true);
      }
    });

    unloadBtn.addEventListener('click', () => {
      try { port && port.postMessage({ type: 'control', cmd: 'unload_request' }); } catch (e){}
      unloadMod();
    });

    // helpful default log
    log('Runtime ready. Waiting for parent init message with transferred MessagePort.');
    setStatus('Waiting for init');

    // expose debug helpers for dev console
    window.__modRuntime = {
      requestHost, installPort, loadAndStart, unloadMod
    };
  })();
  </script>
</body>
</html>
