<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>duckcraft</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/duck.png">

    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: sans-serif;
            background: #87CEEB;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="info">duckcraft - WASD to move, mouse to look, LEFT CLICK to place, RIGHT CLICK to remove</div>
    <div id="crosshair"></div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.querySelector('#gameCanvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB); // Sky blue

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5).normalize();
        scene.add(directionalLight);

        // Materials
        const materials = {
            original: new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Green
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),   // Grey
            testObject: new THREE.MeshLambertMaterial({ color: 0x0000ff }) // Blue
        };

        const blockSize = 2;
        const worldSize = 32;
        const worldDepth = 16;

        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blocks = {}; // Store references to placed blocks

        // Generate terrain
        for (let x = -worldSize; x <= worldSize; x++) {
            for (let z = -worldSize; z <= worldSize; z++) {
                const surfaceHeight = Math.floor(Math.random() * 3) + 1;

                // Surface block
                const surfaceBlock = new THREE.Mesh(blockGeometry, materials.original);
                surfaceBlock.position.set(x, surfaceHeight, z);
                scene.add(surfaceBlock);
                const key = `${x},${surfaceHeight},${z}`;
                blocks[key] = surfaceBlock;

                // Stone layers below
                for (let y = surfaceHeight - 1; y >= 0; y--) {
                    const stoneBlock = new THREE.Mesh(blockGeometry, materials.stone);
                    stoneBlock.position.set(x, y, z);
                    scene.add(stoneBlock);
                    const key = `${x},${y},${z}`;
                    blocks[key] = stoneBlock;
                }
            }
        }

        // Camera setup
        camera.position.set(0, 10, 0);

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Movement flags
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Keyboard controls
        document.addEventListener('keydown', e => {
            switch(e.key.toLowerCase()) {
                case 'w': moveState.forward = true; break;
                case 's': moveState.backward = true; break;
                case 'a': moveState.left = true; break;
                case 'd': moveState.right = true; break;
            }
        });

        document.addEventListener('keyup', e => {
            switch(e.key.toLowerCase()) {
                case 'w': moveState.forward = false; break;
                case 's': moveState.backward = false; break;
                case 'a': moveState.left = false; break;
                case 'd': moveState.right = false; break;
            }
        });

        // Mouse look
        let yaw = 0;
        let pitch = 0;

        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement !== canvas) return;

            const sensitivity = 0.002;
            yaw -= e.movementX * sensitivity;
            pitch -= e.movementY * sensitivity;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        });

        // Lock pointer on click
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        // Place/Remove Test Objects
        document.addEventListener('mousedown', e => {
            if (document.pointerLockElement !== canvas) return;

            // Raycaster for interaction
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(), camera);

            const intersects = raycaster.intersectObjects(Object.values(blocks));

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const face = intersects[0].face.normal;

                const targetPos = new THREE.Vector3(
                    Math.round(point.x + face.x * 0.5),
                    Math.round(point.y + face.y * 0.5),
                    Math.round(point.z + face.z * 0.5)
                );

                const key = `${targetPos.x},${targetPos.y},${targetPos.z}`;

                if (e.button === 0) { // Left click - place
                    if (!blocks[key]) {
                        const newObj = new THREE.Mesh(blockGeometry, materials.testObject);
                        newObj.position.copy(targetPos);
                        scene.add(newObj);
                        blocks[key] = newObj;
                    }
                } else if (e.button === 2) { // Right click - remove
                    if (blocks[key] && blocks[key].material !== materials.stone && blocks[key].material !== materials.original) {
                        scene.remove(blocks[key]);
                        delete blocks[key];
                    }
                }
            }
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const speed = 0.2;
            const dx = Math.sin(yaw) * speed;
            const dz = Math.cos(yaw) * speed;

            if (moveState.forward) {
                camera.position.x -= dx;
                camera.position.z -= dz;
            }
            if (moveState.backward) {
                camera.position.x += dx;
                camera.position.z += dz;
            }
            if (moveState.left) {
                camera.position.x -= dz;
                camera.position.z += dx;
            }
            if (moveState.right) {
                camera.position.x += dz;
                camera.position.z -= dx;
            }

            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            renderer.render(scene, camera);
        }

        animate();

        console.log("Voxel world initialized.");
    </script>
</body>
</html>



